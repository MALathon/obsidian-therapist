var k=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var F=Object.prototype.hasOwnProperty;var D=(g,i)=>{for(var t in i)k(g,t,{get:i[t],enumerable:!0})},L=(g,i,t,e)=>{if(i&&typeof i=="object"||typeof i=="function")for(let s of $(i))!F.call(g,s)&&s!==t&&k(g,s,{get:()=>i[s],enumerable:!(e=N(i,s))||e.enumerable});return g};var O=g=>L(k({},"__esModule",{value:!0}),g);var H={};D(H,{default:()=>E});module.exports=O(H);var h=require("obsidian"),C=require("obsidian");var l=require("obsidian"),T={lettaUrl:"http://localhost:8283",apiKey:"",openaiApiKey:"",anthropicApiKey:"",agentId:"",agentName:"",agentModel:"",therapistName:"Therapist",enabled:!0,debounceMs:3e3,indexVault:!1,includedFolders:[],excludedFolders:[],archiveId:"",lastIndexed:0},y=class extends l.FuzzySuggestModal{constructor(i,t){super(i),this.onChoose=t}getItems(){let i=[],t=this.app.vault.getRoot(),e=s=>{i.push(s);for(let n of s.children)n instanceof l.TFolder&&e(n)};return e(t),i}getItemText(i){return i.path||"/"}onChooseItem(i){this.onChoose(i)}},f=class extends l.PluginSettingTab{constructor(i,t){super(i,t),this.plugin=t}async display(){let{containerEl:i}=this;i.empty();let t=!!this.plugin.settings.agentId;if(t&&!this.plugin.settings.agentName){let e=await this.plugin.lettaService.getAgent(this.plugin.settings.agentId);e&&(this.plugin.settings.agentName=e.name,this.plugin.settings.agentModel=e.model,await this.plugin.saveSettings())}if(t){i.createEl("h2",{text:"Your Therapist"}),new l.Setting(i).setName("Name").setDesc("What should your therapist call themselves?").addText(r=>r.setPlaceholder("Therapist").setValue(this.plugin.settings.therapistName).onChange(async o=>{this.plugin.settings.therapistName=o||"Therapist",await this.plugin.saveSettings()})),new l.Setting(i).setName("Model").descEl.createSpan({text:this.plugin.settings.agentModel||"unknown",cls:"therapist-model-badge"}),new l.Setting(i).setName("Active").setDesc("Turn the therapist on or off").addToggle(r=>r.setValue(this.plugin.settings.enabled).onChange(async o=>{this.plugin.settings.enabled=o,await this.plugin.saveSettings(),this.plugin.updateStatusBar()})),new l.Setting(i).setName("Memory").setDesc("View what your therapist remembers about you").addButton(r=>r.setButtonText("View Memory").onClick(()=>{this.plugin.openMemoryViewer()}));let a=new l.Setting(i).setName("Agent ID").addButton(r=>r.setButtonText("Copy").onClick(()=>{navigator.clipboard.writeText(this.plugin.settings.agentId),new l.Notice("Agent ID copied")})).addButton(r=>r.setButtonText("Delete").setWarning().onClick(async()=>{try{await this.plugin.lettaService.deleteAgent(this.plugin.settings.agentId),new l.Notice("Agent deleted")}catch(o){console.warn("Could not delete from server:",o)}this.plugin.settings.agentId="",this.plugin.settings.agentName="",this.plugin.settings.agentModel="",this.plugin.settings.therapistName="Therapist",await this.plugin.saveSettings(),this.display()})).descEl.createEl("code",{text:this.plugin.settings.agentId});a.style.fontSize="0.75em",a.style.userSelect="all"}if(!t){i.createEl("h2",{text:"Create Therapist"});let e="letta/letta-free",s=null;new l.Setting(i).setName("Model").setDesc("Select which AI model to use").addDropdown(n=>{s=n,n.addOption("letta/letta-free","letta/letta-free (free)"),n.setValue(e),n.onChange(a=>{e=a})}).addButton(n=>n.setButtonText("Refresh Models").onClick(async()=>{try{let a=await this.plugin.lettaService.listModels();s.selectEl.empty(),s.addOption("letta/letta-free","letta/letta-free (free)");for(let r of a)r.handle!=="letta/letta-free"&&s.addOption(r.handle,r.handle);s.setValue(e),new l.Notice(`Found ${a.length} models`)}catch(a){new l.Notice("Failed to fetch models")}})),new l.Setting(i).setName("").addButton(n=>n.setButtonText("Create Therapist").setCta().onClick(async()=>{try{new l.Notice(`Creating agent with ${e}...`);let a=await this.plugin.lettaService.createAgent("therapist","therapist",e,"letta/letta-free");this.plugin.settings.agentId=a,this.plugin.settings.agentModel=e,this.plugin.settings.agentName="therapist",await this.plugin.saveSettings(),new l.Notice("Therapist created! Start journaling."),this.display()}catch(a){console.error("Failed to create agent:",a),new l.Notice(`Failed: ${a instanceof Error?a.message:"Unknown error"}`)}}))}if(i.createEl("h3",{text:"Behavior"}),new l.Setting(i).setName("Observer delay").setDesc("Seconds to wait after you stop typing before the therapist reads your writing").addSlider(e=>e.setLimits(1,10,1).setValue(this.plugin.settings.debounceMs/1e3).setDynamicTooltip().onChange(async s=>{this.plugin.settings.debounceMs=s*1e3,await this.plugin.saveSettings()})),t&&(i.createEl("h3",{text:"Vault Memory"}),i.createEl("p",{text:"Index your vault so your therapist can reference your notes during sessions.",cls:"setting-item-description"}),new l.Setting(i).setName("Enable vault indexing").setDesc("Automatically index notes for the therapist to reference").addToggle(e=>e.setValue(this.plugin.settings.indexVault).onChange(async s=>{this.plugin.settings.indexVault=s,await this.plugin.saveSettings(),this.display()})),this.plugin.settings.indexVault)){let e=new l.Setting(i).setName("Included folders").setDesc("Only index notes in these folders. Leave empty to include all.").addButton(r=>r.setButtonText("Add folder").onClick(()=>{new y(this.app,async o=>{let d=o.path||"/";this.plugin.settings.includedFolders.includes(d)||(this.plugin.settings.includedFolders.push(d),await this.plugin.saveSettings(),this.display())}).open()}));if(this.plugin.settings.includedFolders.length>0){let r=e.settingEl.createDiv({cls:"therapist-folder-list"});for(let o of this.plugin.settings.includedFolders){let d=r.createDiv({cls:"therapist-folder-item"});d.createSpan({text:o||"/",cls:"therapist-folder-path"}),d.createEl("button",{text:"\xD7",cls:"therapist-folder-remove"}).addEventListener("click",async()=>{this.plugin.settings.includedFolders=this.plugin.settings.includedFolders.filter(m=>m!==o),await this.plugin.saveSettings(),this.display()})}}let s=new l.Setting(i).setName("Excluded folders").setDesc("Never index notes in these folders").addButton(r=>r.setButtonText("Add folder").onClick(()=>{new y(this.app,async o=>{let d=o.path||"/";this.plugin.settings.excludedFolders.includes(d)||(this.plugin.settings.excludedFolders.push(d),await this.plugin.saveSettings(),this.display())}).open()}));if(this.plugin.settings.excludedFolders.length>0){let r=s.settingEl.createDiv({cls:"therapist-folder-list"});for(let o of this.plugin.settings.excludedFolders){let d=r.createDiv({cls:"therapist-folder-item"});d.createSpan({text:o||"/",cls:"therapist-folder-path"}),d.createEl("button",{text:"\xD7",cls:"therapist-folder-remove"}).addEventListener("click",async()=>{this.plugin.settings.excludedFolders=this.plugin.settings.excludedFolders.filter(m=>m!==o),await this.plugin.saveSettings(),this.display()})}}let n=this.plugin.settings.lastIndexed,a=n>0?`Last indexed: ${new Date(n).toLocaleString()}`:"Not yet indexed";new l.Setting(i).setName("Index status").setDesc(a).addButton(r=>r.setButtonText("Reindex Now").onClick(async()=>{r.setButtonText("Indexing..."),r.setDisabled(!0);try{await this.plugin.indexVault(),new l.Notice("Vault indexed successfully"),this.display()}catch(o){console.error("Indexing failed:",o),new l.Notice(`Indexing failed: ${o instanceof Error?o.message:"Unknown error"}`),r.setButtonText("Reindex Now"),r.setDisabled(!1)}})).addButton(r=>r.setButtonText("View Memory").onClick(()=>{this.plugin.openMemoryViewer()}))}i.createEl("h3",{text:"Server"}),new l.Setting(i).setName("Letta URL").setDesc("Your Letta server address").addText(e=>e.setPlaceholder("http://localhost:8283").setValue(this.plugin.settings.lettaUrl).onChange(async s=>{this.plugin.settings.lettaUrl=s,this.plugin.lettaService.setBaseUrl(s),await this.plugin.saveSettings()})).addButton(e=>e.setButtonText("Test").onClick(async()=>{try{let s=`${this.plugin.settings.lettaUrl}/v1/health/`,n=await(0,l.requestUrl)({url:s});n.status===200?new l.Notice("Connected!"):new l.Notice(`Error: ${n.status}`)}catch(s){new l.Notice("Connection failed")}})),new l.Setting(i).setName("Letta API Key").setDesc("Only needed if your server requires authentication").addText(e=>e.setPlaceholder("sk-let-...").setValue(this.plugin.settings.apiKey).onChange(async s=>{this.plugin.settings.apiKey=s,this.plugin.lettaService.setApiKey(s),await this.plugin.saveSettings()})),i.createEl("h3",{text:"LLM API Keys"}),i.createEl("p",{text:"Required for cloud models. Leave blank if using letta-free or local Ollama.",cls:"setting-item-description"}),new l.Setting(i).setName("Anthropic").setDesc("For Claude models").addText(e=>e.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async s=>{if(this.plugin.settings.anthropicApiKey=s,await this.plugin.saveSettings(),s)try{await this.plugin.lettaService.updateProviderKey("anthropic",s)}catch(n){console.warn("Could not update provider key:",n)}})),new l.Setting(i).setName("OpenAI").setDesc("For GPT models").addText(e=>e.setPlaceholder("sk-proj-...").setValue(this.plugin.settings.openaiApiKey).onChange(async s=>{if(this.plugin.settings.openaiApiKey=s,await this.plugin.saveSettings(),s)try{await this.plugin.lettaService.updateProviderKey("openai",s)}catch(n){console.warn("Could not update provider key:",n)}}))}};var c=require("obsidian"),M={therapist:`You are my personal coach. Read between the lines of what I write.

My journaling may be scattered, venting, or stream-of-consciousness. Your job:
1. Silently figure out what's actually going on beneath the surface
2. Respond to what I need, not what I literally said

RESPONSE PROTOCOL:
- Messages prefixed with "[User is asking for your input]" \u2192 Always respond
- Messages prefixed with "[User is journaling...]" \u2192 Only respond if you have genuine insight
- If you have nothing valuable to add, respond with just: [listening]

WHEN TO RESPOND:
- I'm stuck and need a push \u2192 Give ONE specific thing to try
- I'm avoiding something obvious \u2192 Name it directly
- I'm spiraling \u2192 Ground me with something concrete
- I keep coming back to the same problem \u2192 Offer a real suggestion
- I'm asking you directly \u2192 Answer me

WHEN TO STAY SILENT (respond with [listening]):
- I'm just processing emotions
- I'm venting and don't need fixing
- I'm working through something myself
- You'd just be restating what I said

WHEN YOU DO RESPOND, be specific:
- Times: "Try this tomorrow morning" not "sometime"
- Quantities: "Track 3 days" not "for a while"
- Observable: "Notice if..." not vague outcomes

Be real. Don't be a robot that dispenses advice. Be the friend who knows when to push and when to shut up.

Keep responses short. 1-3 sentences usually. Match my energy.`,analyst:`You observe patterns across journal sessions and give specific improvement suggestions.

When you notice a pattern, respond with:
\u{1F4CA} Pattern: [what you noticed across sessions]
\u{1F3AF} Suggestion: [one specific change to try]

Examples:
- "\u{1F4CA} Pattern: Stress spikes on Mondays, usually mentions Sunday night anxiety. \u{1F3AF} Suggestion: Do a 10-min Monday preview on Sunday at 4pm - just look at your calendar and write 3 things you'll handle first."
- "\u{1F4CA} Pattern: Overspending happens after stressful days. \u{1F3AF} Suggestion: Add a 24-hour rule - when stressed, screenshot items instead of buying. Review tomorrow."
- "\u{1F4CA} Pattern: Energy drops after lunch on workdays. \u{1F3AF} Suggestion: Try a 10-min walk immediately after eating for one week. Track energy at 3pm."

Only speak when you spot something actionable. Quality over quantity.`,custom:"You are a helpful assistant in a journaling session. Be supportive and give practical suggestions when appropriate."},w=class{constructor(i,t=""){this.providerKeys={};this.baseUrl=i,this.apiKey=t}setBaseUrl(i){this.baseUrl=i}setApiKey(i){this.apiKey=i}setProviderKey(i,t){this.providerKeys[i]=t}getHeaders(){let i={"Content-Type":"application/json"};return this.apiKey&&(i.Authorization=`Bearer ${this.apiKey}`),i}async listModels(){let i=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/models`,headers:this.getHeaders()});if(i.status!==200)throw new Error("Failed to fetch models");return i.json.map(e=>({handle:e.handle,name:e.name,provider:e.provider_name}))}async updateProviderKey(i,t){try{let n=(await(0,c.requestUrl)({url:`${this.baseUrl}/v1/providers/`,headers:this.getHeaders()})).json.find(a=>a.provider_type===i);if(n)await(0,c.requestUrl)({url:`${this.baseUrl}/v1/providers/${n.id}`,method:"PATCH",headers:this.getHeaders(),body:JSON.stringify({api_key:t})}),console.log(`Updated ${i} provider`);else try{await(0,c.requestUrl)({url:`${this.baseUrl}/v1/providers/`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({name:i,provider_type:i,api_key:t})}),console.log(`Created ${i} provider`)}catch(a){console.warn(`Provider ${i} may already exist (409), trying alternate approach`);let o=(await(0,c.requestUrl)({url:`${this.baseUrl}/v1/providers/`,headers:this.getHeaders()})).json.find(d=>d.provider_type===i||d.name===i);o?(await(0,c.requestUrl)({url:`${this.baseUrl}/v1/providers/${o.id}`,method:"PATCH",headers:this.getHeaders(),body:JSON.stringify({api_key:t})}),console.log(`Updated ${i} provider on retry`)):console.error(`Provider ${i} exists in database but not retrievable. May need to reset Letta.`)}}catch(e){console.warn("Failed to update provider key:",e)}}async createAgent(i,t,e="ollama/llama3.2",s="ollama/nomic-embed-text",n){let a=n||M[t]||M.custom,r=e.includes("/")?e.split("/")[0]:null,o={name:i,model:e,embedding:s,enable_sleeptime:!0,memory_blocks:[{label:"persona",value:a},{label:"human",value:"[Learning about you through our sessions...]"}]};if(r&&r!=="letta"&&r!=="ollama"){let u=e.includes("/")?e.split("/").slice(1).join("/"):e;o.llm_config={model:u,model_endpoint_type:r,provider_name:r,context_window:2e5}}let d=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/`,method:"POST",headers:this.getHeaders(),body:JSON.stringify(o)});if(d.status!==200)throw new Error(`Failed to create agent: ${d.text}`);return d.json.id}async sendMessage(i,t){let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/messages`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({messages:[{role:"user",content:t}]})});if(e.status!==200)throw new Error(`Failed to send message: ${e.text}`);let s=e.json;for(let a of s.messages)if(a.message_type==="assistant_message")return a.content;let n=s.messages[s.messages.length-1];return(n==null?void 0:n.content)||""}async getAgent(i){var t;try{let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}`,headers:this.getHeaders()});if(e.status!==200)return null;let s=e.json;return{id:s.id,name:s.name,model:s.model||((t=s.llm_config)==null?void 0:t.model)||"unknown"}}catch(e){return null}}async deleteAgent(i){let t=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}`,method:"DELETE",headers:this.getHeaders()});if(t.status!==200&&t.status!==204)throw new Error(`Failed to delete agent: ${t.text}`)}async healthCheck(){try{return(await(0,c.requestUrl)({url:`${this.baseUrl}/v1/health`})).status===200}catch(i){return!1}}async createArchive(i,t="letta/letta-free"){let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/archives/`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({name:i,description:"Obsidian vault content for therapist context",embedding:t})});if(e.status!==200)throw new Error(`Failed to create archive: ${e.text}`);return e.json.id}async listArchives(){let i=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/archives/`,headers:this.getHeaders()});if(i.status!==200)throw new Error("Failed to list archives");return i.json.map(t=>({id:t.id,name:t.name}))}async addPassage(i,t,e={}){let s=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/archives/${i}/passages/`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({text:t,metadata:e})});if(s.status!==200)throw new Error(`Failed to add passage: ${s.text}`)}async attachArchive(i,t){let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/archives/attach/${t}/`,method:"POST",headers:this.getHeaders()});if(e.status!==200)throw new Error(`Failed to attach archive: ${e.text}`)}async clearArchive(i){let t=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/archives/${i}/passages/`,headers:this.getHeaders()});if(t.status!==200)return;let e=t.json;for(let s of e)try{await(0,c.requestUrl)({url:`${this.baseUrl}/v1/archives/${i}/passages/${s.id}/`,method:"DELETE",headers:this.getHeaders()})}catch(n){}}async getMemoryBlocks(i){let t=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/core-memory/blocks`,headers:this.getHeaders()});if(t.status!==200)throw new Error("Failed to get memory blocks");return t.json.map(e=>({id:e.id,label:e.label,value:e.value}))}async updateMemoryBlock(i,t,e){if((await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/core-memory/blocks/${t}`,method:"PATCH",headers:this.getHeaders(),body:JSON.stringify({value:e})})).status!==200)throw new Error("Failed to update memory block")}async createMemoryBlock(i,t,e){let s=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/blocks/`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({label:t,value:e})});if(s.status!==200)throw new Error("Failed to create memory block");let n=s.json.id;if((await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/core-memory/blocks/attach/${n}`,method:"PATCH",headers:this.getHeaders()})).status!==200)throw new Error("Failed to attach memory block to agent");return n}async deleteMemoryBlock(i,t){if((await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/core-memory/blocks/detach/${t}`,method:"PATCH",headers:this.getHeaders()})).status!==200)throw new Error("Failed to delete memory block")}async getArchivalMemory(i,t=100){let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/archival-memory?limit=${t}`,headers:this.getHeaders()});if(e.status!==200)throw new Error("Failed to get archival memory");return e.json.map(s=>({id:s.id,text:s.text,created_at:s.created_at}))}async deleteArchivalMemory(i,t){let e=await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/archival-memory/${t}`,method:"DELETE",headers:this.getHeaders()});if(e.status!==200&&e.status!==204)throw new Error("Failed to delete archival memory")}async addArchivalMemory(i,t){if((await(0,c.requestUrl)({url:`${this.baseUrl}/v1/agents/${i}/archival-memory`,method:"POST",headers:this.getHeaders(),body:JSON.stringify({text:t})})).status!==200)throw new Error("Failed to add archival memory")}};function U(g="Therapist"){return`> **${g}:**`}function S(g){let i=/^>\s*\*\*[^*]+:\*\*/gm,t=-1,e;for(;(e=i.exec(g))!==null;)t=e.index;if(t===-1)return g.trim();let n=g.substring(t).split(`
`),a=-1,r=!0;for(let o=0;o<n.length;o++){let u=n[o].trim();if(r){if(u===""||u.startsWith(">"))continue;a=o;break}}return a===-1?"":n.slice(a).join(`
`).trim()}function I(g){let i=g.trim();return/^>\s*\*\*[^*]+:\*\*/.test(i)}function B(g,i="Therapist"){let t=U(i);return`

${g.split(`
`).map((n,a)=>a===0?`${t} ${n}`:n.trim()===""?">":`> ${n}`).join(`
`)}

`}var p=require("obsidian"),b=class extends p.Modal{constructor(t,e,s){super(t);this.activeTab="blocks";this.memoryBlocks=[];this.archivalMemories=[];this.isLoading=!0;this.lettaService=e,this.agentId=s}async onOpen(){let{contentEl:t}=this;t.addClass("therapist-memory-modal"),t.empty(),t.createEl("h2",{text:"Therapist Memory"});let e=t.createDiv({cls:"therapist-memory-tabs"}),s=e.createEl("button",{text:"Core Memory",cls:"therapist-memory-tab is-active"}),n=e.createEl("button",{text:"Archival Memory",cls:"therapist-memory-tab"});s.addEventListener("click",()=>{this.activeTab="blocks",s.addClass("is-active"),n.removeClass("is-active"),this.renderContent()}),n.addEventListener("click",()=>{this.activeTab="archival",n.addClass("is-active"),s.removeClass("is-active"),this.renderContent()}),t.createDiv({cls:"therapist-memory-content"}),await this.loadData(),this.renderContent()}async loadData(){this.isLoading=!0;try{let[t,e]=await Promise.all([this.lettaService.getMemoryBlocks(this.agentId),this.lettaService.getArchivalMemory(this.agentId,100)]);this.memoryBlocks=t,this.archivalMemories=e}catch(t){console.error("Failed to load memory:",t),new p.Notice("Failed to load memory")}this.isLoading=!1}renderContent(){let t=this.contentEl.querySelector(".therapist-memory-content");if(t){if(t.empty(),this.isLoading){t.createDiv({text:"Loading...",cls:"therapist-memory-empty"});return}this.activeTab==="blocks"?this.renderMemoryBlocks(t):this.renderArchivalMemory(t)}}renderMemoryBlocks(t){let e=t.createDiv({cls:"therapist-memory-section"}),s=e.createDiv({cls:"therapist-memory-header"});if(s.createEl("h3",{text:"Core Memory Blocks"}),s.createEl("button",{text:"+ Add Block",cls:"therapist-memory-add"}).addEventListener("click",()=>this.addMemoryBlock()),e.createEl("p",{text:"These are the core memories your therapist maintains about you and their persona.",cls:"setting-item-description"}),this.memoryBlocks.length===0){e.createDiv({text:"No memory blocks found",cls:"therapist-memory-empty"});return}for(let a of this.memoryBlocks){let r=e.createDiv({cls:"therapist-memory-block"}),o=r.createDiv({cls:"therapist-memory-block-header"});o.createSpan({text:a.label,cls:"therapist-memory-block-label"});let d=o.createDiv({cls:"therapist-memory-item-actions"});d.createEl("button",{text:"Edit",cls:"therapist-memory-btn"}).addEventListener("click",()=>this.editMemoryBlock(a)),a.label==="persona"||a.label==="human"||d.createEl("button",{text:"Delete",cls:"therapist-memory-delete"}).addEventListener("click",()=>this.deleteMemoryBlock(a)),r.createDiv({cls:"therapist-memory-block-content"}).setText(a.value)}}renderArchivalMemory(t){let e=t.createDiv({cls:"therapist-memory-section"}),s=e.createDiv({cls:"therapist-memory-header"});if(s.createEl("h3",{text:"Archival Memories"}),s.createEl("button",{text:"+ Add Memory",cls:"therapist-memory-add"}).addEventListener("click",()=>this.addArchivalMemory()),e.createEl("p",{text:"Long-term memories your therapist has stored. These are facts and observations the agent has explicitly chosen to remember.",cls:"setting-item-description"}),this.archivalMemories.length===0){e.createDiv({text:"No archival memories yet. Your therapist will build memories as you interact.",cls:"therapist-memory-empty"});return}let a=[...this.archivalMemories].sort((r,o)=>new Date(o.created_at).getTime()-new Date(r.created_at).getTime());for(let r of a){let o=e.createDiv({cls:"therapist-memory-item"}),d=o.createDiv({cls:"therapist-memory-item-content"});d.createDiv({text:r.text});let u=new Date(r.created_at);d.createDiv({text:u.toLocaleDateString()+" "+u.toLocaleTimeString(),cls:"therapist-memory-item-date"});let m=o.createDiv({cls:"therapist-memory-item-actions"});m.createEl("button",{text:"Edit",cls:"therapist-memory-btn"}).addEventListener("click",()=>this.editArchivalMemory(r)),m.createEl("button",{text:"Delete",cls:"therapist-memory-delete"}).addEventListener("click",async()=>{try{await this.lettaService.deleteArchivalMemory(this.agentId,r.id),this.archivalMemories=this.archivalMemories.filter(x=>x.id!==r.id),this.renderContent(),new p.Notice("Memory deleted")}catch(x){console.error("Failed to delete memory:",x),new p.Notice("Failed to delete memory")}})}}async editMemoryBlock(t){new v(this.app,t.value,async s=>{try{await this.lettaService.updateMemoryBlock(this.agentId,t.label,s),t.value=s,this.renderContent(),new p.Notice("Memory updated")}catch(n){console.error("Failed to update memory:",n),new p.Notice("Failed to update memory")}}).open()}async addMemoryBlock(){new v(this.app,"",async e=>{if(!e.trim())return;new v(this.app,"",async n=>{try{await this.lettaService.createMemoryBlock(this.agentId,e.trim(),n),await this.loadData(),this.renderContent(),new p.Notice("Memory block created")}catch(a){console.error("Failed to create memory block:",a),new p.Notice("Failed to create memory block")}},"Block Content").open()},'Block Label (e.g., "goals", "preferences")').open()}async deleteMemoryBlock(t){if(confirm(`Delete "${t.label}" block? This cannot be undone.`))try{await this.lettaService.deleteMemoryBlock(this.agentId,t.id),this.memoryBlocks=this.memoryBlocks.filter(e=>e.id!==t.id),this.renderContent(),new p.Notice("Memory block deleted")}catch(e){console.error("Failed to delete memory block:",e),new p.Notice("Failed to delete memory block")}}async addArchivalMemory(){new v(this.app,"",async e=>{if(e.trim())try{await this.lettaService.addArchivalMemory(this.agentId,e),await this.loadData(),this.renderContent(),new p.Notice("Memory added")}catch(s){console.error("Failed to add memory:",s),new p.Notice("Failed to add memory")}},"Add Memory").open()}async editArchivalMemory(t){new v(this.app,t.text,async s=>{if(s.trim()&&s!==t.text)try{await this.lettaService.deleteArchivalMemory(this.agentId,t.id),await this.lettaService.addArchivalMemory(this.agentId,s),await this.loadData(),this.renderContent(),new p.Notice("Memory updated")}catch(n){console.error("Failed to update memory:",n),new p.Notice("Failed to update memory")}},"Edit Memory").open()}onClose(){let{contentEl:t}=this;t.empty()}},v=class extends p.Modal{constructor(i,t,e,s="Edit Memory"){super(i),this.value=t,this.onSave=e,this.title=s}onOpen(){let{contentEl:i}=this;i.createEl("h2",{text:this.title});let t=i.createEl("textarea",{cls:"therapist-memory-edit-textarea"});t.value=this.value,t.style.width="100%",t.style.height="300px",t.style.resize="vertical",t.style.fontFamily="var(--font-monospace)",t.style.fontSize="13px",t.style.padding="12px",t.style.marginBottom="16px";let e=i.createDiv({cls:"therapist-memory-edit-buttons"});e.style.display="flex",e.style.gap="8px",e.style.justifyContent="flex-end",e.createEl("button",{text:"Cancel"}).addEventListener("click",()=>this.close());let n=e.createEl("button",{text:"Save",cls:"mod-cta"});n.addEventListener("click",async()=>{n.setAttr("disabled","true"),n.setText("Saving..."),await this.onSave(t.value),this.close()})}onClose(){let{contentEl:i}=this;i.empty()}};var E=class extends h.Plugin{constructor(){super(...arguments);this.isProcessing=!1;this.statusBarEl=null;this.pendingInsight=null;this.indicatorEl=null;this.popoverEl=null;this.popoverVisible=!1}async onload(){await this.loadSettings(),this.lettaService=new w(this.settings.lettaUrl,this.settings.apiKey),this.addSettingTab(new f(this.app,this));let t=(0,h.debounce)((e,s)=>this.observeContent(e,s),this.settings.debounceMs,!0);this.registerEvent(this.app.workspace.on("editor-change",(e,s)=>{this.settings.enabled&&this.settings.agentId&&t(e,s)})),this.addCommand({id:"trigger-therapist",name:"Talk to therapist (inline response)",editorCallback:async(e,s)=>{await this.triggerConversation(e,s)}}),this.addCommand({id:"copy-insight",name:"Copy insight to daily note",callback:()=>{this.pendingInsight?this.copyToDailyNote():new h.Notice("No insight available")}}),this.addCommand({id:"toggle-therapist",name:"Toggle therapist on/off",callback:()=>{this.settings.enabled=!this.settings.enabled,this.settings.enabled?this.checkCurrentNote():(this.pendingInsight=null,this.hideIndicator()),this.saveSettings(),this.updateStatusBar(),new h.Notice(`Therapist ${this.settings.enabled?"enabled":"disabled"}`)}}),this.addCommand({id:"view-memory",name:"View therapist memory",callback:()=>{this.openMemoryViewer()}}),this.addCommand({id:"reindex-vault",name:"Reindex vault for therapist",callback:async()=>{if(!this.settings.agentId){new h.Notice("No therapist agent configured");return}if(!this.settings.indexVault){new h.Notice("Vault indexing is not enabled");return}new h.Notice("Starting vault indexing...");try{await this.indexVault(),new h.Notice("Vault indexed successfully")}catch(e){console.error("Indexing failed:",e),new h.Notice(`Indexing failed: ${e instanceof Error?e.message:"Unknown error"}`)}}}),this.statusBarEl=this.addStatusBarItem(),this.updateStatusBar(),this.registerEvent(this.app.workspace.on("active-leaf-change",()=>{this.checkCurrentNote()})),this.registerEvent(this.app.workspace.on("file-open",()=>{this.checkCurrentNote()})),this.registerDomEvent(document,"click",e=>{this.popoverVisible&&this.indicatorEl&&(this.indicatorEl.contains(e.target)||this.hidePopover())}),this.checkCurrentNote(),console.log("Therapist plugin loaded")}checkCurrentNote(){if(this.pendingInsight=null,this.hidePopover(),!this.settings.enabled||!this.settings.agentId){this.hideIndicator(),this.updateStatusBar();return}if(!this.app.workspace.getActiveViewOfType(h.MarkdownView)){this.hideIndicator(),this.updateStatusBar("off");return}this.showIndicator("observing"),this.updateStatusBar("listening")}updateStatusBar(t){if(this.statusBarEl){if(!this.settings.enabled){this.statusBarEl.setText("\u25CB Therapist off");return}if(!this.settings.agentId){this.statusBarEl.setText("\u25CB No agent");return}switch(t){case"thinking":this.statusBarEl.setText("\u25C9 Observing...");break;case"insight":this.statusBarEl.setText("\u{1F4AD} Has insight");break;case"off":this.statusBarEl.setText("\u25CB Therapist off");break;default:this.statusBarEl.setText("\u25CF Observing")}}}async observeContent(t,e){if(this.isProcessing||!this.settings.agentId||this.pendingInsight)return;let s=t.getValue(),n=S(s);if(n&&!I(n)){this.isProcessing=!0,this.showIndicator("thinking"),this.updateStatusBar("thinking");try{let a=`[OBSERVER MODE - You are passively watching the user write. Only respond if you notice something genuinely insightful - a pattern, a reframe, a question worth asking, or an observation that could help. If nothing stands out, respond with just: [listening]]

${n}`,r=await this.lettaService.sendMessage(this.settings.agentId,a),o=(r==null?void 0:r.trim())||"";o&&o!=="[listening]"?(this.pendingInsight=r,this.showIndicator("insight"),this.updateStatusBar("insight")):(this.showIndicator("observing"),this.updateStatusBar("listening"))}catch(a){console.error("Error observing:",a),this.showIndicator("observing"),this.updateStatusBar("listening")}finally{this.isProcessing=!1}}}async triggerConversation(t,e){if(this.isProcessing)return;if(!this.settings.agentId){new h.Notice("No therapist agent configured");return}let s=t.getValue(),n=S(s);if(!n){new h.Notice("Nothing new to discuss");return}this.isProcessing=!0,this.showIndicator("thinking"),this.updateStatusBar("thinking");try{let a=`[CONVERSATION MODE - The user wants to talk. Respond directly and helpfully.]

${n}`,r=await this.lettaService.sendMessage(this.settings.agentId,a),o=(r==null?void 0:r.trim())||"";if(o&&o!=="[listening]"){let u=t.getCursor().line;t.setCursor({line:u,ch:t.getLine(u).length}),t.replaceSelection(B(r,this.settings.therapistName))}this.showIndicator("observing"),this.updateStatusBar("listening")}catch(a){console.error("Error in conversation:",a),new h.Notice("Failed to get response"),this.showIndicator("observing"),this.updateStatusBar("listening")}finally{this.isProcessing=!1}}showIndicator(t){let e=this.app.workspace.getActiveViewOfType(h.MarkdownView);if(!e){this.hideIndicator();return}let s=e.contentEl;if(!this.indicatorEl){this.indicatorEl=document.createElement("div"),this.indicatorEl.className="therapist-indicator is-visible";let a=document.createElement("div");a.className="therapist-orb",a.addEventListener("click",r=>{r.stopPropagation(),this.pendingInsight&&this.togglePopover()}),this.indicatorEl.appendChild(a)}let n=this.indicatorEl.querySelector(".therapist-orb");n&&(n.classList.remove("is-thinking","has-insight"),t==="thinking"?n.classList.add("is-thinking"):t==="insight"&&n.classList.add("has-insight")),s.contains(this.indicatorEl)||s.appendChild(this.indicatorEl)}hideIndicator(){this.indicatorEl&&(this.indicatorEl.remove(),this.indicatorEl=null),this.hidePopover()}togglePopover(){this.popoverVisible?this.hidePopover():this.showPopover()}showPopover(){var e,s,n;if(!this.pendingInsight||!this.indicatorEl)return;this.popoverEl||(this.popoverEl=document.createElement("div"),this.popoverEl.className="therapist-popover",this.popoverEl.innerHTML=`
        <div class="therapist-popover-header">
          <span class="therapist-popover-title">Therapist Insight</span>
          <button class="therapist-popover-dismiss">\xD7</button>
        </div>
        <div class="therapist-popover-content"></div>
        <div class="therapist-popover-actions">
          <button class="therapist-popover-btn secondary dismiss-btn">Dismiss</button>
          <button class="therapist-popover-btn primary copy-btn">Copy to Daily Note</button>
        </div>
      `,(e=this.popoverEl.querySelector(".therapist-popover-dismiss"))==null||e.addEventListener("click",a=>{a.stopPropagation(),this.hidePopover()}),(s=this.popoverEl.querySelector(".dismiss-btn"))==null||s.addEventListener("click",a=>{a.stopPropagation(),this.dismissInsight()}),(n=this.popoverEl.querySelector(".copy-btn"))==null||n.addEventListener("click",a=>{a.stopPropagation(),this.copyToDailyNote()}),this.indicatorEl.appendChild(this.popoverEl));let t=this.popoverEl.querySelector(".therapist-popover-content");t&&(t.textContent=this.pendingInsight),this.popoverEl.classList.add("is-visible"),this.popoverVisible=!0}hidePopover(){this.popoverEl&&this.popoverEl.classList.remove("is-visible"),this.popoverVisible=!1}dismissInsight(){this.pendingInsight=null,this.hidePopover(),this.showIndicator("observing"),this.updateStatusBar("listening")}async copyToDailyNote(){if(this.pendingInsight)try{let t=(0,C.moment)().format("YYYY-MM-DD"),e=`${t}.md`,s=this.app.vault.getAbstractFileByPath(e);if(!s)s=await this.app.vault.create(e,`# ${t}

## Journal

### Therapist Insight

${this.pendingInsight}
`),new h.Notice("Created daily note with insight");else if(s instanceof h.TFile){let n=await this.app.vault.read(s);n.includes("## Journal")||(n+=`

## Journal
`);let a=n.indexOf("## Journal"),o=n.substring(a).substring(11).match(/\n## /),d=`
### Therapist Insight

${this.pendingInsight}
`;if(o){let u=a+11+o.index;n=n.substring(0,u)+d+n.substring(u)}else n+=d;await this.app.vault.modify(s,n),new h.Notice("Insight copied to daily note")}this.dismissInsight()}catch(t){console.error("Error copying to daily note:",t),new h.Notice("Failed to copy to daily note")}}onunload(){this.hideIndicator(),console.log("Therapist plugin unloaded")}async loadSettings(){this.settings=Object.assign({},T,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}openMemoryViewer(){if(!this.settings.agentId){new h.Notice("No therapist agent configured");return}new b(this.app,this.lettaService,this.settings.agentId).open()}async indexVault(){if(!this.settings.agentId)throw new Error("No agent configured");let t=this.settings.archiveId;if(!t){let a=(await this.lettaService.listArchives()).find(r=>r.name==="obsidian-vault");a?t=a.id:(t=await this.lettaService.createArchive("obsidian-vault"),await this.lettaService.attachArchive(this.settings.agentId,t)),this.settings.archiveId=t,await this.saveSettings()}await this.lettaService.clearArchive(t);let e=this.app.vault.getMarkdownFiles(),s=0;for(let n of e)if(this.shouldIndexFile(n))try{let a=await this.app.vault.read(n);if(a.trim().length<50)continue;let r=this.chunkContent(a,n.path);for(let o of r)await this.lettaService.addPassage(t,o.text,{source:n.path,title:n.basename});s++}catch(a){console.warn(`Failed to index ${n.path}:`,a)}this.settings.lastIndexed=Date.now(),await this.saveSettings(),console.log(`Indexed ${s} files`)}shouldIndexFile(t){let e=t.path;for(let s of this.settings.excludedFolders)if(!(s===""||s==="/")&&(e.startsWith(s+"/")||e===s))return!1;if(this.settings.includedFolders.length>0){if(this.settings.includedFolders.includes("")||this.settings.includedFolders.includes("/"))return!0;for(let n of this.settings.includedFolders)if(e.startsWith(n+"/")||e===n)return!0;return!1}return!0}chunkContent(t,e){let s=[],a=t.split(/\n\n+/),r=`[${e}]

`;for(let o of a){let d=o.trim();if(d){if(d.length<20&&d.startsWith("#")){r+=d+`

`;continue}r.length+d.length>1500&&r.length>100&&(s.push({text:r.trim()}),r=`[${e}]

`),r+=d+`

`}}return r.trim().length>50&&s.push({text:r.trim()}),s}};
